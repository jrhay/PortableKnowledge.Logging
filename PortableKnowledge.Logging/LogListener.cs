using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

// PortableKnowledge Logging Framework for .NET
// (C) Portable Knowledge, LLC
//
// Released to the public under the Portable Knowledge Open Source Component License
//
// Permission is hereby granted, free of charge, to any person or organization obtaining a 
// copy of the software and accompanying documentation covered by this license (the "Software")
// to use, reproduce, display, distribute, execute, and transmit the Software, and to prepare 
// derivative works of the Software, and to permit third-parties to whom the Software is 
// furnished to do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including the above license
// grant, this restriction and the following disclaimer, must be included in all copies of the 
// Software, in whole or in part, and all derivative works of the Software, unless such copies 
// or derivative works are solely in the form of machine-executable object code generated by 
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
// PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE 
// DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR 
// OTHER DEALINGS IN THE SOFTWARE.  IN NO CASE DOES THE USE OF THIS SOFTWARE EXPRES OR IMPLY 
// ANY PARTNERSHIP OR COOPERATION WITH THE AUTHORS OR COPYRIGHT HOLDERS OF THIS SOFTWARE.

namespace PortableKnowledge.Logging
{
    /// <summary>
    /// Base Log Listener class.  Defines virtual methods for handling Logging Events.
    /// </summary>
    public class LogListener
    {
        /// <summary>
        /// LogLevel filtering for this Log Listener.  Set to NONE for no filtering,
        /// or a bitmask of LogLevel values to listen to log events of just those levels
        /// (default: LogLevel.None)
        /// </summary>
        public LogLevel LevelFilter = LogLevel.None;

        /// <summary>
        /// Log we are currently subscribed to, so we can unsubscribe if needed.
        /// </summary>
        private Log subscribedLog = null;

        #region Initialization

        /// <summary>
        /// LogListener instances must be registered with the log they are listening to;
        /// The default constructor should never be called in use (hence, a private constructor).
        /// </summary>
        private LogListener()
        {
        }

        /// <summary>
        /// Initialize a new LogListener instance registered to receive Log Events from a 
        /// specific log.  By default, all log events are received.
        /// </summary>
        /// <param name="log">Log instance to register this listener with</param>
        public LogListener(Log log)
        {
            if ((log != null) && (log.GetType() != typeof(NullLog)))
            {
                log.OnLogMessageReceived += new LogEventHandler(OnLogMessageReceived);
                subscribedLog = log;
            }
        }

        /// <summary>
        /// Finalize the LogListener.  Unsubscribes from any subscribed log.
        /// </summary>
        ~LogListener()
        {
            Unsubscribe();
        }

        /// <summary>
        /// Unregister from the currently-registered log (stop receiving log events from the log)
        /// Has no effect if not currently subscribed.
        /// </summary>
        public void Unsubscribe()
        {
            if (subscribedLog != null)
            {
                subscribedLog.OnLogMessageReceived -= OnLogMessageReceived;
                subscribedLog = null;
            }
        }

        #endregion

        #region Log Message Processing

        /// <summary>
        /// Virtual method called whenever a new item is added to the registered log.
        /// Base method simply writes the item message and level to the Visual Studio Debug output; 
        /// derived classes should override this method to do something more exotic.
        /// </summary>
        /// <param name="item">Details of newly-added log item</param>
        public virtual void ProcessLogMessage(LogItem item)
        {
            System.Diagnostics.Debug.WriteLine(item.ToString());
        }

        /// <summary>
        /// Receives a log message from the log, and passes it on to ProcessLogMessage()
        /// if the new message matches the currently-active logging filter
        /// </summary>
        /// <param name="sender">Log sending the new message</param>
        /// <param name="e">Details of the log message</param>
        public virtual void OnLogMessageReceived(Log sender, LogEventArgs e)
        {
            if ((LevelFilter == LogLevel.None) || ((e.Item.Level & LevelFilter) > 0))
                ProcessLogMessage(e.Item);
        }

        #endregion
    }
}
