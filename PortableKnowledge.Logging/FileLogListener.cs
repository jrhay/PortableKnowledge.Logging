using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.IO;
using System.Threading;

// PortableKnowledge Logging Framework for .NET
// (C) Portable Knowledge, LLC
//
// Released to the public under the Portable Knowledge Open Source Component License
//
// Permission is hereby granted, free of charge, to any person or organization obtaining a 
// copy of the software and accompanying documentation covered by this license (the "Software")
// to use, reproduce, display, distribute, execute, and transmit the Software, and to prepare 
// derivative works of the Software, and to permit third-parties to whom the Software is 
// furnished to do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including the above license
// grant, this restriction and the following disclaimer, must be included in all copies of the 
// Software, in whole or in part, and all derivative works of the Software, unless such copies 
// or derivative works are solely in the form of machine-executable object code generated by 
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
// PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE 
// DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR 
// OTHER DEALINGS IN THE SOFTWARE.  IN NO CASE DOES THE USE OF THIS SOFTWARE EXPRES OR IMPLY 
// ANY PARTNERSHIP OR COOPERATION WITH THE AUTHORS OR COPYRIGHT HOLDERS OF THIS SOFTWARE.

namespace PortableKnowledge.Logging
{
    /// <summary>
    /// LogListener which sends logging messages to a specific file on disk.
    /// The File updates are guarenteed to be thread safe.  Log file may safely be deleted
    /// at any time, and will be re-created automatically.  The full path to the file may
    /// be created if it doesn't exist.  Any errors writing to the file are silently ignored.
    /// </summary>
    public class FileLogListener : LogListener
    {
        /// <summary>
        /// The full path to the file to write the log to
        /// </summary>
        protected String _filePath;

        /// <summary>
        /// Object to lock on to sync file access across threads
        /// </summary>
        protected Object _fileSync = new Object();

        /// <summary>
        /// TRUE while the file log writer is running.  In current implementation, this is
        /// always TRUE.
        /// </summary>
        protected Boolean _logRunning = true;

        /// <summary>
        /// Queue containing strings to write to the file.  Strings will be written to the file
        /// in atomic, block fashion by the writer thread.
        /// </summary>
        protected Queue<String> _logMessages = new Queue<String>();

        /// <summary>
        /// Thread to actually write log messages to the file.  Writes are done in a background
        /// thread so log writing will have low overhead.
        /// </summary>
        protected Thread _logWriterThread = null;

        /// <summary>
        /// Initialize a new FileLogListener instance to write all Log Events from a spcified
        /// Log to a specific file path
        /// </summary>
        /// <param name="log">Log instance to register this listener with</param>
        /// <param name="FilePathName">Full pathname of file to write log to</param>
        public FileLogListener(Log log, String FilePathName) : base(log)
        {
            this._filePath = FilePathName;
        }

        /// <summary>
        /// Initialize a new FileLogListener instance to write all Log Events from a spcified
        /// Log to a specific file path, optionally clearing the log file to start
        /// </summary>
        /// <param name="log">Log instance to register this listener with</param>
        /// <param name="FilePathName">Full pathname of file to write log to</param>
        /// <param name="ClearAtStart">If TRUE, delete the file at initialization</param>
        public FileLogListener(Log log, String FilePathName, Boolean ClearAtStart)
            : this(log, FilePathName)
        {
            if (ClearAtStart)
            {
                lock (_fileSync)
                {
                    try
                    {
                        System.IO.File.Delete(FilePathName);
                    }
                    catch
                    {
                    }
                }
            }
        }

        /// <summary>
        /// Full pathname of log file.  Pathname may be changed at any time
        /// </summary>
        public String FilePath
        {
            get { return _filePath; }
            set
            {
                lock (_fileSync)
                {
                    // Ask log writer thread to exit
                    _logRunning = false;
                    Monitor.Pulse(_fileSync);
                    if ((_logWriterThread != null) && (!String.IsNullOrEmpty(_filePath)))
                        _logWriterThread.Join();

                    // Change the file pathname
                    _filePath = value;
                    _logRunning = true;
                }

                // Resume writing to the (new) log file
                ProcessLogMessage(null);
            }
        }

        /// <summary>
        /// Worker method to write the log messages to the log file in an atomic manner
        /// </summary>
        private void AddMessagesToFile()
        {
            lock (_fileSync)
            {
                while (_logRunning)
                {
                    // Write all log messages to file in a block
                    if (_logMessages.Count > 0)
                    {
                        try
                        {
                            EnsureDirectory(Path.GetDirectoryName(_filePath));

                            FileStream Writer = new FileStream(_filePath, FileMode.Append);

                            while (_logMessages.Count > 0)
                            {
                                byte[] MessageBytes = UTF8Encoding.UTF8.GetBytes(_logMessages.Dequeue() + "\r\n");
                                Writer.Write(MessageBytes, 0, MessageBytes.Length);
                            }

                            Writer.Flush();
                            Writer.Close();
                        }
                        catch
                        {
                            // Ignore any errors (probably bad filepath, etc.)
                        }

                    }

                    // Wait for more log messages to appear
                    Monitor.Wait(_fileSync);
                }
            }
        }

        /// <summary>
        /// Called whenever a new item is added to the registered log.  Adds the LogItem
        /// to the assocaited log file, creating the log file/path if needed.  File writes
        /// are performed on a seperate thread so that return is immediate.
        /// </summary>
        /// <param name="item">Details of newly-added log item</param>
        public override void ProcessLogMessage(LogItem item)
        {
            lock (_fileSync)
            {
                if ((_logWriterThread == null) && (!String.IsNullOrEmpty(_filePath)))
                {
                    _logWriterThread = new Thread(AddMessagesToFile);
                    _logWriterThread.IsBackground = true;
                    _logWriterThread.Name = "FileLog Listener: " + _filePath;
                    _logWriterThread.Start();
                }

                if (item != null)
                    _logMessages.Enqueue(item.ToString(" "));

                Monitor.Pulse(_fileSync);
            }
        }

        #region Helper Methods

        /// <summary>
        /// Ensure that a full directory path exists.  If the specified directory, or any
        /// intermediate directory, doesn't exist, it is created.
        /// </summary>
        /// <param name="Path">Full path to ensure existance</param>
        private static void EnsureDirectory(DirectoryInfo Path)
        {
            if (Path.Parent != null)
                EnsureDirectory(Path.Parent);
            if (!Path.Exists)
                Path.Create();
        } 

        /// <summary>
        /// Ensure that a full directory path exists.  If the specified directory, or any
        /// intermediate directory, doesn't exist, it is created.
        /// </summary>
        /// <param name="Path">Full path to ensure existance</param>
        private static void EnsureDirectory(string Path)
        {
            EnsureDirectory(new DirectoryInfo(Path));
        } 

        #endregion
    }
}
